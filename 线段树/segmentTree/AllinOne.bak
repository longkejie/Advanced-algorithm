/*************************************************************************
	> File Name: 604.cpp
	> Author: xiaox
	> Mail: buaa_xiaox@live.com
	> Created Time: Mon 28 Dec 2020 09:52:18 AM CST
 ************************************************************************/

#include<iostream>
#include<algorithm>
#include<vector>
#include<cstdio>
#include "./common/segmengtTree.h"
using namespace std;

//#define debug(...) printf(__VA_ARGS__)
#define debug(...) {}

//==============SgTreeNode=============
template <typename T>
class SgTreeNode
{
private:
    T data;
    int l, r, mid, len;
    SgTreeNode *lch, *rch;   
public:
    void down();
    void update();
    void cover();
    auto query();
    SgTreeNode(int l_, int r_, const vector<T> &data_)
    {
        l = l_;  r = r_;  mid = (l + r) / 2;  len = (r - l + 1);
        if (l == r){
            lch = NULL;  rch = NULL;  data = data_[l];
        }else{
            lch = new SgTreeNode(l, mid, data_);
            rch = new SgTreeNode(mid + 1, r, data_);
            update();
        }
    }
    void modify()
    {
        if (data.x <= l && r <= data.y) { cover();  return;}
        down();
        if (lch->r >= data.x) lch->modify();
        if (rch->l <= data.y) rch->modify();
        update();
    }
    ~SgTreeNode()   { if (l != r) { delete lch;  delete rch;}}
};
//================SegmentTree================
template <typename Type>
class SegmentTree
{
public:
    Type OP;
    SgTreeNode<Type> *root;
    void buildtree(const vector<Type> &data_)       { root = new SgTreeNode<Type>(1, data_.size() - 1, data_);}
    void modify(int x)                              { OP.x = OP.y = x;  root->modify();}
    void modify(int x, int y)                       { OP.x = x; OP.y = y;  root->modify();}
    auto getval(int x)                              { OP.x = OP.y = x;  return root->query();}
    auto getval(int x, int y)                       { OP.x = x;  OP.y = y;  return root->query();}
    ~SegmentTree()                                  { delete root;}
};

//===============OJ222======================
struct data_max
{
    int max;
    int keyvalue()  { return max; }
    static int x, y;
    static int val;
};
template<> void SgTreeNode<data_max>::down()        { }
template<> void SgTreeNode<data_max>::update()      { data.max = max(lch->data.max, rch->data.max);}
template<> void SgTreeNode<data_max>::cover()       { data.max = data.val;}
template<> auto SgTreeNode<data_max>::query()
{
    debug("query (%d, %d) in (%d, %d)  with data.max = %d\n", x , y, l, r, data.max);
    if (data.y < l || r < data.x) return 1 << 31;
    if (data.x <= l && r <= data.y) return data.max;
    return max(lch->query(), rch->query());
}
//=================OJ223=====================
struct data_int
{
    long long tag;
    long long sum;
    long long keyvalue()    { return sum; }
    static int x, y;
    static long long val;
};
#define push(ch) ch->data.sum += data.tag * ch->len;  ch->data.tag += data.tag
template<> void SgTreeNode<data_int>::down()    { push(lch);  push(rch);  data.tag = 0;}
template<> void SgTreeNode<data_int>::update()  { data.tag = 0; data.sum = lch->data.sum + rch->data.sum;}
template<> void SgTreeNode<data_int>::cover()   { data.tag += data.val; data.sum += data.val * len;}
template<> auto SgTreeNode<data_int>::query()
{
    if (data.x <= l && r <= data.y) return data.sum;
    down();
    long long ans = 0;
    if (lch->r >= data.x) ans += lch->query();
    if (rch->l <= data.y) ans += rch->query();
    return ans;
}
#undef push
//===================OJ224====================
struct data_multy
{
    long long tag_mult, tag_plus;
    void tag_init()         { tag_mult = 1;  tag_plus = 0;}
    long long sum;
    long long keyvalue()    { return sum;}
    static int x,y;
    static int ifmultiply; // 1:multiply; 0:plus;
    static int val;
};
//step1: multiply;  step2: plus;  eg: new_sum = sum * tag_mult + tag_plus;
#define push(child) {\
    child->data.sum = child->data.sum * data.tag_mult + data.tag_plus * child->len;\
    child->data.tag_mult *= data.tag_mult;\
    child->data.tag_plus = child->data.tag_plus * data.tag_mult + data.tag_plus;\
}  
template<> void SgTreeNode<data_multy>::down()      { push(lch);  push(rch);  data.tag_init();}
template<> void SgTreeNode<data_multy>::update()    { data.tag_init();  data.sum = lch->data.sum + rch->data.sum;}
template<> void SgTreeNode<data_multy>::cover()
{
    if (data.ifmultiply) {
        data.sum *= data.val;
        data.tag_mult *= data.val;
        data.tag_plus *= data.val;
    }else{
        data.sum += data.val * len;
        data.tag_plus += data.val;
    }
}
template<> auto SgTreeNode<data_multy>::query()
{
    if (data.x <= l && r <= data.y) return data.sum;
    down();
    long long ans = 0;
    if (lch->r >= data.x) ans += lch->query();
    if (rch->l <= data.y) ans += rch->query();
    return ans;
}
#undef push
//===================OJ604===================
struct data_ljq
{
    int ord;
    int num;
};
template<> void SgTreeNode<data_ljq>::down();
template<> void SgTreeNode<data_ljq>::update();
template<> void SgTreeNode<data_ljq>::cover();
template<> void SgTreeNode<data_ljq>::modify();
template<> auto SgTreeNode<data_ljq>::query();




void OJ222()
{
    int n, m, a, b, c;
    cin >> n >> m;
    vector<data_max> init_data(n + 1);
    for (int i = 1; i <= n; i++){
        scanf("%d", &init_data[i].max);
    }
    SegmentTree<data_max> tree;
    tree.buildtree(init_data);
    data_max OP;
    for (int i = 1; i <= m; i++){
        scanf("%d%d%d",&a,&b,&c);
        switch(a){
            case 1:
            {
                OP.val = c;
                tree.modify(b);
                break;
            }
            case 2:
            {
                if (b > c)
                {
                    printf("-2147483648\n");
                    break;
                }
                printf("%d\n", tree.getval(b, c));
                break;
            }
        }
    }
    return;
}
void OJ223()
{
    int n, m, a, b, c, d;
    scanf("%d%d", &n, &m);
    vector<data_int> init_data(n+1);
    for (int i = 1; i <= n; i++){
        int tmp;
        scanf("%d", &tmp);
        init_data[i].tag = 0;
        init_data[i].sum = tmp;
    }
    SegmentTree<data_int> tree;
    tree.buildtree(init_data);
    data_int OP;
    for (int i = 1; i <= m; i++){
        scanf("%d%d%d", &a, &b, &c);
        switch (a){
            case 1:
            {
                scanf("%d", &d);
                OP.val = d;
                tree.modify(b, c);
                break;
            }
            case 2:
            {
                printf("%lld\n", tree.getval(b, c));
                break;
            }
        }
    }
    return;
}

int main()
{
    OJ222();
    OJ223();
    return 0;
}
